{"componentChunkName":"component---src-templates-blog-post-js","path":"/study/os-study/cpu-scheduling/","result":{"data":{"site":{"siteMetadata":{"title":"{ 모리 막장저장소 }","author":"kwonmory","siteUrl":"https://blog.kwonmory.com","comment":{"disqusShortName":"","utterances":"kwonmory/kwonmory.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"3d81c80c-8c1d-5ac7-9f64-b89f55d2a997","excerpt":"시작하기 CPU-IO 버스트 사이클  출처 링크 프로세스는 와 가 번갈아가면서 작업을 처리된다. CPU Burst CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계 또는 IO를 수행 후 다음 IO를 수행하기 까지 일련의 작업 IO Burst IO요청이 발생해 커널에 의해 입출력 작업을 진행하는 단계 또는 CPU 버스트가 끝나고 다음 CPU 버스트 수행까지의 일련의 작업 CPU 바운드 프로세스 IO작업을 거의 수행하지 않아 가 길게 나타나는 프로세스 IO 바운드 프로세스 IO…","html":"<h1 id=\"시작하기\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\" aria-label=\"시작하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시작하기</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Quiz&gt;\n    1. CPU 스케줄링이 왜 필요할까요?\n    2. 스케줄링이 필요한 상황은 언제일까요?\n    3. 요즘 운영체제에선 선점형으로 스케줄링 알고리즘을 많이 사용하는데, 이유가 있을까요?\n    4. 선점형으로 스케줄링을 하게 된다면 주의할 부분이 있을까요?\n    5. 디스패처는 무슨 일을 할까요?\n    6. 만약 디스패처 레이턴시가 길다고 하면 라운드 로빈의 어떤 설정을 수정하면 좋을까요?\n    7. 스케줄링 성능 지표는 무엇이 있나요?\n    8. 스케줄링 알고리즘 알고 있는게 뭐뭐 있나요?\n    9. 콘보이 현상은 무엇일까요? 그리고 어디서 나타나나요?\n    10. SJF의 단점은 무엇일까요?\n    11. 우선순위 스케줄링 알고리즘의 단점은 무엇이고 보완하기 위한 방법이 있나요? 없다면 없다고 말하셔도 됩니다.\n    12. 라운드 로빈 알고리즘에서 타임퀀텀이 길 때, 짧을 때 어떤 현상이 일어날까요?\n    13. 라운드 로빈의 장점은 뭐라고 생각하세요?\n    14. 멀티 레벨 큐에 레디 큐에 고정 우선순위 방식을 사용할 때, 어떤 문제점이 있을까요? 그리고 어떻게 해결할 수 있을까요?\n    15. 멀티 레벨 큐와 멀티 피드백 큐를 비교하면서 설명해줄래요?\n    16. 다중 처리기 스케줄링에서 고려 해야할만한 현상은 뭐가 있을까요?\n    17. 실시간 스케줄링에서 어떤 스케줄링 알고리즘을 사용할까요?\n    18. 스케줄링 알고리즘 성능을 평가하기 위한 방법은 무엇이 있나요?\n    19. 스케줄링을 만들어본적이 있나요?\n    20. 본인이 만약 라운드 로빈 스케줄링 알고리즘을 만든다고 하면 어떤 자료구조를 사용하실껀가요? 그 이유는 뭐죠?\n    21. 프로세스 A 에서 커널 모드로 갔다가 다시 프로세스 A 로 CPU를 할당한다면 이를 컨텍스트 스위칭이라고 하나요?\n&lt;/Quiz&gt;</code></pre></div>\n<h2 id=\"cpu-io-버스트-사이클\" style=\"position:relative;\"><a href=\"#cpu-io-%EB%B2%84%EC%8A%A4%ED%8A%B8-%EC%82%AC%EC%9D%B4%ED%81%B4\" aria-label=\"cpu io 버스트 사이클 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU-IO 버스트 사이클</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 122%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAIAAAB1KUohAAAACXBIWXMAAAsSAAALEgHS3X78AAACJ0lEQVQ4y6VUW3eaQBj0//+XPuTJPjTR2lZtU5W0RmIDR4TDApGbym1ZwA5sQzBCTs7p98BZFma/mdnZ7Z0aVRQFnoyx4Bic3lG9yyksAXxzJmMZX/ctcJIksiRJj4/KZtP8O47jNE3zPC+qageHYTC4uRmPx4IgAFALwZjoOiHENAw0aAenlEp/1rqmWgbZu+4LoziGEHR+JecMHFHm0XyfFh4t7Ig97cOcd47iLMs6NXMh6j7py/6HxeZqqV8tyVA7phWmpF2V6zht4OrphskvzREUc74xFoq5Im6W5yWjKMqqyqvXDrej6Od0Iq/XRFOltWgRvXbb87zj8YhVmrLP3Y6i60/XK1F0HKcpEhinqt1uB1M799kry7VtG33CMMyfafN9fos2pfRwOGyVrVHZAzzvD7cJtlknjm13gjPGwApNIAwsIJWHBJ1f9WwH+74Pba7rNmOIhVjKLuPda54n8PzY7w8Hg++TKfqfx5MYZTzNznhSmtwvl7Ikq6razAPANKXQjxU7DwY+0wSCQZ9BO3x6l2b+k2lZk+mP4XA0+vLt8+jrbC7wSABsmvhoeb7fCbYd5+7u9+3tbDZfzOfC6l7MnrMdBAG2nZ/Tdtr8rIMh/6mm2sr5DFzfEqCKqNQztUOXg97pP+ofeKsoD6KIuwbJ1jRNrwobi/GTVZZhGJaJW8iAc5qqwoIXMLYeCSmTxFjcKPiMyTKwaYoBrcJbHm9WGvkXsSJu3gG/sdgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"CPU-IO-Burst\"\n        title=\"CPU-IO-Burst\"\n        src=\"/static/93cd30c7686343f29f7032feea5b5fdd/00d43/44cr44n443ot-2020-10-08-15-29-44.png\"\n        srcset=\"/static/93cd30c7686343f29f7032feea5b5fdd/5a46d/44cr44n443ot-2020-10-08-15-29-44.png 300w,\n/static/93cd30c7686343f29f7032feea5b5fdd/0a47e/44cr44n443ot-2020-10-08-15-29-44.png 600w,\n/static/93cd30c7686343f29f7032feea5b5fdd/00d43/44cr44n443ot-2020-10-08-15-29-44.png 1000w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p><a href=\"https://zoomkoding.github.io/os/2019/04/28/os-5.html\">출처 링크</a></p>\n<p>프로세스는 <code class=\"language-text\">CPU burst</code>와 <code class=\"language-text\">IO burst</code>가 번갈아가면서 작업을 처리된다.</p>\n<h3 id=\"cpu-burst\" style=\"position:relative;\"><a href=\"#cpu-burst\" aria-label=\"cpu burst permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU Burst</h3>\n<p>CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계</p>\n<p>또는</p>\n<p>IO를 수행 후 다음 IO를 수행하기 까지 일련의 작업</p>\n<h3 id=\"io-burst\" style=\"position:relative;\"><a href=\"#io-burst\" aria-label=\"io burst permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IO Burst</h3>\n<p>IO요청이 발생해 커널에 의해 입출력 작업을 진행하는 단계</p>\n<p>또는</p>\n<p>CPU 버스트가 끝나고 다음 CPU 버스트 수행까지의 일련의 작업</p>\n<h3 id=\"cpu-바운드-프로세스\" style=\"position:relative;\"><a href=\"#cpu-%EB%B0%94%EC%9A%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"cpu 바운드 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU 바운드 프로세스</h3>\n<p>IO작업을 거의 수행하지 않아 <code class=\"language-text\">CPU burst</code>가 길게 나타나는 프로세스</p>\n<h3 id=\"io-바운드-프로세스\" style=\"position:relative;\"><a href=\"#io-%EB%B0%94%EC%9A%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4\" aria-label=\"io 바운드 프로세스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IO 바운드 프로세스</h3>\n<p>IO요청이 빈번하게 일어나고 <code class=\"language-text\">CPU burst</code>가 짧게 나타나는 프로세스</p>\n<p>주로 대화형 프로그램에 해당한다.</p>\n<h2 id=\"cpu-스케줄링이-필요한-이유\" style=\"position:relative;\"><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0\" aria-label=\"cpu 스케줄링이 필요한 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU 스케줄링이 필요한 이유</h2>\n<p>프로세스마다 CPU를 사용하는 패턴이 상이하기 때문에 효율적으로 CPU자원을 사용하기 위해서</p>\n<h2 id=\"cpu-스케줄러\" style=\"position:relative;\"><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC\" aria-label=\"cpu 스케줄러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CPU 스케줄러</h2>\n<p>CPU스케줄러는 준비 상태(레디큐)에 있는 프로세스들 중에서 어떤 프로세스에게 CPU를 사용하게 할 것인지 결정한다.</p>\n<blockquote>\n<ul>\n<li>레디 큐는 여러가지 자료구조로 만들어질 수 있다.(우선순위큐, 트리, 연결 리스트 등)</li>\n<li>레디 큐에는 각 프로세스들의 PCB로 연결되어있다.</li>\n</ul>\n</blockquote>\n<h3 id=\"스케줄링이-필요한-상황\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%99%A9\" aria-label=\"스케줄링이 필요한 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링이 필요한 상황</h3>\n<ol>\n<li>실행 상태에서 프로세스가 필요에 의해 IO요청으로 인해서 블럭된 상태로 바뀌는 경우</li>\n<li>실행 상태에서 프로세스가 종료되는 경우</li>\n<li>실행 상태에서 타이머 인터럽트가 발생해서 준비 상태로 넘어가는 경우</li>\n<li>IO요청으로 블럭 상태에 있던 프로세스의 IO처리가 완료가 되어 인터럽트가 발생되어 기존에 작업되던 프로세스가 준비 상태로 바뀌는 경우</li>\n</ol>\n<h3 id=\"선점preemptive과-비선점nonpreemptive\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%A0%90preemptive%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90nonpreemptive\" aria-label=\"선점preemptive과 비선점nonpreemptive permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선점(preemptive)과 비선점(nonpreemptive)</h3>\n<p>비선점은 프로세스가 작업을 완료하는 동안까지는 CPU를 빼앗기지 않는 방식을 말한다.</p>\n<p>선점은 비선점과 반대로 CPU를 사용하는 프로세스가 작업 도중 CPU를 빼앗기는 방식을 말한다.</p>\n<blockquote>\n<p>윈도우, 맥, 리눅스 ,유닉스를 포함한 모든 최신 운영체제에서는 대부분 선점 스케줄링 알고리즘을 사용한다.</p>\n</blockquote>\n<p>위에서 말한 1과 2번은 <code class=\"language-text\">비선점 방식</code>이며, 3과 4번은 <code class=\"language-text\">선점 방식</code>이다.</p>\n<p>선점 방식은 데이터가 다수의 프로세스에 의해 공유될 때 경쟁 상태에 들어가게 되면 데이터의 일관성이 무너질 수 있다는 점으로 <code class=\"language-text\">데이터 동기화</code>를 신경 써줘야한다.</p>\n<p>뒤에 동기 문제를 다루는 파트에서 보기로 하자.(mutex)</p>\n<h2 id=\"디스패처\" style=\"position:relative;\"><a href=\"#%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B2%98\" aria-label=\"디스패처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디스패처</h2>\n<p>CPU스케줄러에 의해 레디큐에 있던 프로세스를 선택되었다면 기존에 작업하던 프로세스에서 새로운 프로세스로 넘어가는 작업이 필요하다.</p>\n<p>이를 디스패처라는 커널 모듈이 해주고 있다.</p>\n<p>디스패처는</p>\n<ol>\n<li>현재 수행중이였던 프로세스의 컨텍스트(문맥)을 PCB에 저장을 하고, 새롭게 선택된 프로세스의 컨텍스트(문맥)을 PCB에서 가져온다(문맥 복원 작업)</li>\n<li>커널 모드에서 사용자 모드로 전환하여 프로그램에게 CPU 제어권을 넘기게 되며,</li>\n<li>프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동시켜준다.</li>\n</ol>\n<h3 id=\"디스패처-지연시간\" style=\"position:relative;\"><a href=\"#%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B2%98-%EC%A7%80%EC%97%B0%EC%8B%9C%EA%B0%84\" aria-label=\"디스패처 지연시간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디스패처 지연시간</h3>\n<p>기존 프로세스에서 새로운 프로세스로 전환하는 시간을 말한다.</p>\n<p>지연시간은 컨텍스트 스위칭으로 인한 오버헤드에 해당된다.</p>\n<p>그래서 빈번한 컨텍스트 스위칭이 발생하게 된다면, 성능상 이슈가 발생할 수도 있다.</p>\n<h2 id=\"스케줄링-성능-평가-지표\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80-%EC%A7%80%ED%91%9C\" aria-label=\"스케줄링 성능 평가 지표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링 성능 평가 지표</h2>\n<ol>\n<li>\n<p>CPU활용도(CPU utilization)</p>\n<ul>\n<li>전체 시간 중 CPU가 명령어를 수행한 시간의 비율</li>\n<li>CPU 휴먼 상태를 최대한 줄이는 것이 중요한 목표 중 하나</li>\n</ul>\n</li>\n<li>\n<p>처리량(throughput)</p>\n<ul>\n<li>주어진 시간 동안 <code class=\"language-text\">CPU burst</code>를 완료한 프로세스의 수</li>\n</ul>\n</li>\n<li>\n<p>소요시간(turnaround time)</p>\n<ul>\n<li>CPU요청 시점부터 시작해서 해당 <code class=\"language-text\">CPU burst</code>가 끝날 때까지 걸린 시간</li>\n</ul>\n</li>\n<li>\n<p>대기시간(waiting time)</p>\n<ul>\n<li><code class=\"language-text\">CPU burst</code> 시간 동안 기다린 총합</li>\n<li>처음 이해하기 어려웠던 부분인데, 작업하려고 들어온 양을 다 처리하기 위해서 기다린 시간을 의미</li>\n</ul>\n</li>\n<li>\n<p>응답시간(response time)</p>\n<ul>\n<li>CPU요청 시점부터 처음으로 CPU를 얻을때까지의 시간</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>소요시간은 <strong>해당</strong> <code class=\"language-text\">CPU burst</code> 시간까지 포함이며, 응답시간은 미포함이다.</p>\n</blockquote>\n<p>그리고</p>\n<p><code class=\"language-text\">CPU이용률과 처리량</code>을 최대화하고, <code class=\"language-text\">처리 시간, 대기 시간, 응답 시간</code>을 최소화하는 것이 바람직하다.</p>\n<h2 id=\"스케줄링-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"스케줄링 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링 알고리즘</h2>\n<h3 id=\"fcfsfrist-come-first-served\" style=\"position:relative;\"><a href=\"#fcfsfrist-come-first-served\" aria-label=\"fcfsfrist come first served permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FCFS(Frist Come First Served)</h3>\n<p>프로세스가 레드 큐에 도착한 순서대로 CPU를 할당하는 방식</p>\n<p>제일 이해하기 쉬운 스케줄링 알고리즘이다.</p>\n<p>비선점형이다.</p>\n<p>대화식 시스템에는 적합하지 않다.</p>\n<p><strong>FCFS의 평균 대기시간</strong>은 레디 큐에 들어온 프로세스의 버스트타임에 따라서 다르게 나타난다.</p>\n<h4 id=\"2가지-예시\" style=\"position:relative;\"><a href=\"#2%EA%B0%80%EC%A7%80-%EC%98%88%EC%8B%9C\" aria-label=\"2가지 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2가지 예시</h4>\n<ol>\n<li>\n<p>긴 버스트타임을 가지고 있는 프로세스가 처음 들어온 뒤 짧은 버스트타임을 가지는 프로세스들이 들어왔다고 가정했을 때</p>\n<ul>\n<li>먼저 도착한 긴 프로세스를 처리할 때, 뒤에 있는 짧은 프로세스들은 오랜시간 동안 대기하게 된다.- 이에 따라 평균 대기시간이 길어짐을 볼 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>짧은 버스트타임의 프로세스들이 있고 맨 뒤에 긴 버스트타임의 프로세스로 처리하게 된다면</p>\n<ul>\n<li>평균 대기시간은 첫번째 경우보다 짧아짐을 볼 수 있다.</li>\n</ul>\n</li>\n</ol>\n<p>즉, 괜히 앞에 버스트타임이 긴 프로세스 때문에 뒤에 있는 프로세스들에게 영향을 미친다.</p>\n<p>이렇게 버스트타임이 짧은 작업들이 긴 프로세스들보다 늦게 레디큐에 왔다는 이유로 오랜 시간을 기다리게 되는 현상을 <code class=\"language-text\">콘보이(Convoy effect)현상</code> 이라고 한다.</p>\n<h4 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h4>\n<p>장점</p>\n<ul>\n<li>스케줄링의 이해와 구현이 단순함</li>\n<li>레디 큐에 있는 프로세스 모두 실행되기 때문에 기아가 없음</li>\n</ul>\n<p>단점</p>\n<ul>\n<li>대화식 프로세스엔 부적합함</li>\n<li>먼저 긴 프로세스가 들어오면 대기 시간이 늘어남</li>\n<li>콘보이 현상이 발생함</li>\n</ul>\n<h3 id=\"sjfshortest-job-first\" style=\"position:relative;\"><a href=\"#sjfshortest-job-first\" aria-label=\"sjfshortest job first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SJF(Shortest Job First)</h3>\n<p>버스트타임이 짧은 프로세스에게 먼저 CPU를 할당하는 방식이다.</p>\n<p>SJF는 평균 대기 시간이 가장 짧은 알고리즘으로 최적의 알고리즘으로 불리온다.</p>\n<p>하지만, 현실적으로 어떤 프로세스의 버스트타임이 짧은 프로세스인지 파악하기 어려워 구현하기가 어렵다.</p>\n<p>그래서 이에 대한 대응으로 <code class=\"language-text\">CPU burst</code>타임을 예측을 하는 방법을 생각해볼 수 있다.</p>\n<p>이전 <code class=\"language-text\">CPU burst</code>들의 길이를 지수평균을 내서 예측한다.</p>\n<h4 id=\"선점과-비선점\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%A0%90%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90\" aria-label=\"선점과 비선점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선점과 비선점</h4>\n<p>SJF는 선점과 비선점 두가지 방식으로 나눠볼 수 있다.</p>\n<p>선점 방식 같은 경우 현재 상태에서 버스트타임이 더 짧은게 있다면 기존에 처리하고 있던 프로세스의 CPU를 빼앗고 더 짧은 프로세스에게 CPU를 주게 된다.</p>\n<p>선점의 방식 경우 SRF(Shortest Remaining Time First) 또는 SRTF라고 불린다.</p>\n<blockquote>\n<p>참고로 만약 동일한 시간에 준비 큐에 동일한 버스트타임을 가진 프로세스들이 동시에 온다면 선점 비선점은 동일하게 처리하게 된다.</p>\n</blockquote>\n<h4 id=\"정리-1\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-1\" aria-label=\"정리 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h4>\n<p>장점</p>\n<ul>\n<li>짧은 작업을 먼저 신속하게 처리함으로 평균 대기시간이 짧음</li>\n</ul>\n<p>단점</p>\n<ul>\n<li>아무래도 버스트타임이 짧은 프로세스에게 우선권이 부여되어 처리되기 때문에, 버스트타임이 긴 프로세스에게는 기회가 안올 수도 있다. 이런 현상을 기아(starvation)현상이라고 한다.</li>\n<li>버스트타임을 예측하기가 어렵기 때문에 사실 실용적이지 못함</li>\n</ul>\n<h3 id=\"우선순위-스케줄링priority\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81priority\" aria-label=\"우선순위 스케줄링priority permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선순위 스케줄링(Priority)</h3>\n<p>SJF와 비슷한 방식이다.(버스트타임 &#x3C;-> 우선순위)</p>\n<p>우선순위에 따라서 프로세스를 처리하는 방식이다.</p>\n<h4 id=\"우선순위-정하는-방법\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"우선순위 정하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선순위 정하는 방법</h4>\n<p>우선순위를 정하는 방법은 크게 내부적인 요소와 외부적인 요소로 나뉜다.</p>\n<p>내부적인 요소로: 메모리 요구, 열린 파일의 수, 평균 IO버스트의 평균 CPU 버스트에 대한 비율, 시간 제한</p>\n<p>외부적인 요소로 : 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 유형과 양, 정치적인 요소</p>\n<h4 id=\"선점과-비선점-1\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%A0%90%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90-1\" aria-label=\"선점과 비선점 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선점과 비선점</h4>\n<p>SJF와 동일하게 선점과 비선점 방식을 사용하고 있다.</p>\n<h4 id=\"기아현상-보완\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%95%84%ED%98%84%EC%83%81-%EB%B3%B4%EC%99%84\" aria-label=\"기아현상 보완 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기아현상 보완</h4>\n<p>노잉 기법을 사용하는 방법이 있다.</p>\n<p>노잉 기법은 기다리는 시간이 길어지면 해당 프로세스에게 우선순위를 높혀주는 기법이다.</p>\n<h4 id=\"정리-2\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-2\" aria-label=\"정리 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h4>\n<p>장점</p>\n<ul>\n<li>우선순위에 따라 프로세스 처리가 가능하다는 점</li>\n</ul>\n<p>단점</p>\n<ul>\n<li>SJF와 동일하게, 기아 현상이 발생함</li>\n</ul>\n<h3 id=\"라운드-로빈round-robin\" style=\"position:relative;\"><a href=\"#%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%A1%9C%EB%B9%88round-robin\" aria-label=\"라운드 로빈round robin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>라운드 로빈(Round Robin)</h3>\n<p>타임퀀텀 또는 타임슬라이스라는 제한시간 초를 가지고 있다.</p>\n<p>보통 레디 큐를 원형 큐로 설계한다.</p>\n<p>타임퀀텀 만큼 프로세스가 CPU를 사용하게 해주고 해당 시간이 넘어가면 작업 중인 프로세스는 CPU를 빼았고 레디큐로 넘겨버린다.</p>\n<p>즉, 타임퀀텀 2초에 10초의 시간을 쓰는 프로세스가 5개가 있다고 하면 2초 쓰고 다음 프로세스로 넘어가고 2초쓰고 다음 프로세스로 넘어간다.</p>\n<p>물론, 타임퀀텀보다 적은 버스트타임이면 그 전에 끝내고 다음 프로세스에게 CPU를 할당한다.</p>\n<p>라운드로빈은 모든 프로세스의 다음 CPU를 할당 받는 최대 시간을 알 수 있다.</p>\n<p>프로세스 개수가 n이라고 하고, 타임 퀀텀이 q라고 한다면 (n-1)q 시간 이내로 CPU는 무조건 할당받게 되어있다.</p>\n<p>라운드로빈은 빠른 응답을 제공해주기 때문에 대화형 프로세스에게 적합하다.</p>\n<p>만약에 버스트타임에 따라서 소요 시간이 비례하기 때문에 일부 공정하다고 볼 수 있다.</p>\n<h4 id=\"기본-목적\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EB%AA%A9%EC%A0%81\" aria-label=\"기본 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 목적</h4>\n<p>버스트타임이 짧은 프로세스에게는 빨리 CPU를 제공해줌과 긴 프로세스가 불이익을 당하지 않도록 하기 위함이다.</p>\n<h4 id=\"타임퀀텀\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%84%ED%80%80%ED%85%80\" aria-label=\"타임퀀텀 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타임퀀텀</h4>\n<p>타임퀀텀 시간을 길게 잡을 때랑 짧게 잡을 때 성능상 차이가 있다.</p>\n<p>길게 잡는다고 하면, 라운드 로빈은 FCFS와 비슷한 결과를 나타낼 수 있다.</p>\n<p>예를들어보자.</p>\n<p>타임퀀텀이 100초라고 가정하고,</p>\n<p>프로세스 5개가 각각 5초의 부스트타임을 가진다고 한다면 그대로 프로세스 5개가 FCFS처럼 작동할 것이다.</p>\n<p>반대로!</p>\n<p>짧게 잡는다면,</p>\n<p>프로세스에게 CPU를 넘겨주는 작업이 늘어나게 된다. 즉, 컨텍스트 스위칭이 많이 일어나게 된다.</p>\n<p>컨텍스트 스위칭은 오버헤드를 초래한다.</p>\n<p>그래서 오버헤드가 커지게 된다.</p>\n<p>그리고</p>\n<p>총 처리 시간은 타임 퀀텀 크기에 따라서 좌우가 된다. 그리고 타임 퀀턴의 크기가 증가하더라도 반드시 개선되지는 않는다.</p>\n<blockquote>\n<ul>\n<li>실제로 대부분의 현대 운영체제들은 타임 퀀텀을 10에서 100밀리초로 할당하고 있다고 한다.</li>\n<li>보통 컨텍스트 스윙칭까지 10마이크로초 미만이라고 한다.</li>\n</ul>\n</blockquote>\n<h4 id=\"정리-3\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-3\" aria-label=\"정리 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h4>\n<p>장점</p>\n<ul>\n<li>모든 프로세스가 공정하게 작업이 부여되며, 기아가 발생하지 않음</li>\n<li>짧은 응답시간을 제공한다.</li>\n<li>최악의 응답시간을 알 수가 있다.</li>\n</ul>\n<p>단점</p>\n<ul>\n<li>타임퀀텀을 잘 조절해야한다.</li>\n<li>하드웨어 타이머가 필요하다.</li>\n<li>평균 처리 시간이 높다. 왜냐하면 타임 퀀텀만큼 프로세스를 실행하게 되기 때문이다.</li>\n</ul>\n<h3 id=\"멀티-레벨-큐multi-level-queue\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%EB%A0%88%EB%B2%A8-%ED%81%90multi-level-queue\" aria-label=\"멀티 레벨 큐multi level queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 레벨 큐(Multi Level Queue)</h3>\n<p>레디 큐를 여러 개로 분할하여 관리하는 스케줄링 기법이다.</p>\n<p>큐가 여러 개 있으니, 프로세스가 들어왔을 때, 어떤 큐에게 보내야되는지 결정하는 메커니즘이 필요하다.</p>\n<p>일반적으로는 프로세스 성격에 따라 관리한다.</p>\n<p>빠른 응답을 필요로 하는 대화형 작업과 그렇지 않는 작업으로 나눠서 프로세스를 레디큐에 프로세스를 넣는다.</p>\n<p>전자를 전위 큐, 후자를 후위 큐라고 불리기도 한다.</p>\n<p>전위 큐에서는 응답 시간이 빠르다는 점으로 보통 라운드 로빈 알고리즘을 사용한다.</p>\n<p>후위 큐에서는 응답 시간보다 계산 위주이기 때문에 FCFS 알고리즘을 사용해 컨텍스트 스위칭을 줄여 오버헤드를 줄이도록 한다.</p>\n<h4 id=\"보통의-우선순위\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%ED%86%B5%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"보통의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보통의 우선순위</h4>\n<ol>\n<li>실시간 프로세스</li>\n<li>시스템 프로세스</li>\n<li>대화형 프로세스</li>\n<li>배치 프로세스</li>\n</ol>\n<h4 id=\"각-큐별로-스케줄링\" style=\"position:relative;\"><a href=\"#%EA%B0%81-%ED%81%90%EB%B3%84%EB%A1%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"각 큐별로 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각 큐별로 스케줄링</h4>\n<p>큐 안에서의 스케줄링도 외에도 각 큐별로 스케줄링도 필요하다.</p>\n<p><code class=\"language-text\">고정 우선순위 방식</code>을 사용할 수가 있다.</p>\n<p>고정 우선순위 방식은 각 큐에 우선순위를 고정시켜 놓는다.</p>\n<p>그리고 높은 우선순위 큐에 프로세스가 있다면 우선적으로 처리하고, 비어있다면 다음 우선순위가 높은 큐를 처리하는 방식이다.</p>\n<p>하지만 이런 방식을 취하게 되면, 우선순위가 낮은 큐는 처리가 안될 위험이 있다.(기아현상)</p>\n<p>그래서</p>\n<p><code class=\"language-text\">타임 슬라이드 방식</code>을 사용할 수 있다.</p>\n<p>각 큐별로 CPU사용 시간을 비율로 할당하여 제공한다.</p>\n<p>예로 전위 큐 80% 후위 큐 20%를 주어서 기아현상을 방지할 수 있다.</p>\n<h4 id=\"정리-4\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-4\" aria-label=\"정리 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h4>\n<p>장점</p>\n<ul>\n<li>응답이 빠름</li>\n</ul>\n<p>단점</p>\n<ul>\n<li>여러 개의 준비큐와 스케줄링 알고리즘 때문에 추가 오버 헤드가 발생함</li>\n<li>우선순위가 낮은 프로세스는 기아를 겪을 수도 있음</li>\n</ul>\n<h3 id=\"멀티-레벨-피드백-큐multi-level-feedback-queue\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%EB%A0%88%EB%B2%A8-%ED%94%BC%EB%93%9C%EB%B0%B1-%ED%81%90multi-level-feedback-queue\" aria-label=\"멀티 레벨 피드백 큐multi level feedback queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 레벨 피드백 큐(Multi Level Feedback Queue)</h3>\n<p>이 또한 여러 개의 큐로 구성되어있다.</p>\n<p>기존에는 프로세스들이 영구적으로 하나의 큐에만 할당되었지만</p>\n<p>멀티 레벨 피드백 큐에서는 프로세스가 다른 큐로도 이동이 가능하다는 것이다.</p>\n<p>하지만 큐의 개수나 각 큐를 위한 스케줄링 알고리즘</p>\n<p>프로세스 이동 방법 등을 신경쓰며 설계해야하기 때문에 복잡한 알고리즘이다.</p>\n<h4 id=\"정리-5\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-5\" aria-label=\"정리 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h4>\n<p>장점</p>\n<ul>\n<li>\n<p>프로세스의 다양한 성격을 반영해 구현할 수 있다는 장점이 있다.</p>\n<ul>\n<li>예로, 노잉 기법을 구현할 수도 있다.</li>\n</ul>\n</li>\n<li>우선순위가 낮은 큐에서 오래 기다린다면 우선순위가 높은 큐로 프로세스를 이동시켜서 기아 문제를 해결 할 수 있다.</li>\n</ul>\n<p>단점</p>\n<ul>\n<li>설계와 구현이 매우 복잡하다.</li>\n</ul>\n<blockquote>\n<p>작업 시간이 빠른 프로세스는 더 빠른 서비스가 가능하도록 제공하고, 작업이 긴 프로세스는 문맥 교환 없이 CPU작업에만 열중할 수 있도록 FCFS 방식을 채택하도록 만들 수도 있다.</p>\n</blockquote>\n<h3 id=\"다중-처리기-스케줄링\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%A4%91-%EC%B2%98%EB%A6%AC%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"다중 처리기 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다중 처리기 스케줄링</h3>\n<p>CPU가 여러 개인 시스템을 다중 처리기 시스템이라고 한다.</p>\n<p>여러 개의 CPU가 사용 가능하니, 부하를 공유할 수 있다.</p>\n<p>여러 CPU가 레디 큐에있는 프로세스를 가져다가 처리하는 방식이다.</p>\n<p>알아서 CPU가 처리해주면 좋겟지만,</p>\n<p>어떤 프로세스는 특정 CPU에서만 수행되어야 한다고 할때, 문제가 생길 수 있다.</p>\n<p>또는 한쪽 CPU에게만 작업이 편중되는 현상이 일어날 수도 있다.</p>\n<p>이를 방지하기 위해서 CPU별로 부하를 적절히 분산되도록 부하 분산 매커니즘이 필요하게 된다.</p>\n<h4 id=\"대칭형-비대칭형-다중-처리\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%B9%AD%ED%98%95-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%98%95-%EB%8B%A4%EC%A4%91-%EC%B2%98%EB%A6%AC\" aria-label=\"대칭형 비대칭형 다중 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대칭형, 비대칭형 다중 처리</h4>\n<p>대칭형은 각 CPU가 알아서 스케줄링을 결정하는 방식이며, 비대칭형은 한 CPU가 스케줄링 및 데이터 접근을 책임지고 나머지 CPU는 그에 따르는 방식이다.</p>\n<h3 id=\"실시간-스케줄링\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"실시간 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실시간 스케줄링</h3>\n<p>쉽게 말해 데드라인이 있는 스케줄링이다.</p>\n<p>경성과 연성 실시간 시스템으로 분류할 수 있다.</p>\n<p>경성은 미사일 발사라던지, 원자로 제어 등 시간을 꼭 데드라인 시간에 맞게 지켜야하는 시스템을 말한다. 그렇지 않으면 시스템에 큰 문제가 발생하는 시스템이다.</p>\n<p>연성은 데드라인은 있지만, 데드라인을 지키지 않아도 큰 문제는 아닌 시스템이다. 보통 VOD나 스트리밍들이 예로 있다.</p>\n<h4 id=\"edfearlist-deadline-first\" style=\"position:relative;\"><a href=\"#edfearlist-deadline-first\" aria-label=\"edfearlist deadline first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EDF(Earlist Deadline First)</h4>\n<p>데드라인이 얼마 남지 않은 요청을 먼저 처리하는 스케줄링이다.</p>\n<p>일반 프로세스보다 우선순위가 높게 할당해서 먼저 처리된다.</p>\n<h2 id=\"스케줄링-알고리즘-성능-평가\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80\" aria-label=\"스케줄링 알고리즘 성능 평가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링 알고리즘 성능 평가</h2>\n<p>스케줄링 알고리즘 성능을 평가하는 방법으로 결정론적 모델링, 큐잉모델, 시뮬레이션, 구현 등이 있다.</p>\n<h3 id=\"결정론적-모델링deterministic\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EC%A0%95%EB%A1%A0%EC%A0%81-%EB%AA%A8%EB%8D%B8%EB%A7%81deterministic\" aria-label=\"결정론적 모델링deterministic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결정론적 모델링(deterministic)</h3>\n<p>평가 방법으로 분석적 평가가 있는데</p>\n<p>분석적 평가는 작업에 부하를 주어 알고리즘의 성능을 평가하는 방법이다.</p>\n<p>분석적 평가 유형 중 결정론적 모델링이 있다.</p>\n<p>사전에 정의된 특정한 작업 부하를 가지고, 각 알고리즘의 성능을 평가하는 방법이다.</p>\n<p>결정론적 모델링은 단순하고 빠르다는 장점이 있다.</p>\n<p>하지만, 정확한 값을 원하면 정확한 입력이 필요하고, 응답 결과도 해당 입력 데이터에 대한 경우에만 적용된다.</p>\n<p>그래서 주로 스케줄링 알고리즘을 설명하고 예를 제공하는데 사용한다고 한다.</p>\n<h3 id=\"큐잉-모델\" style=\"position:relative;\"><a href=\"#%ED%81%90%EC%9E%89-%EB%AA%A8%EB%8D%B8\" aria-label=\"큐잉 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>큐잉 모델</h3>\n<blockquote>\n<p>어렵네..</p>\n</blockquote>\n<p>내 언어로 해석하자면..</p>\n<p><code class=\"language-text\">CPU와 IO burst</code>의 분포의 데이터를 가지고 특정 CPU 버스트의 확률을 나타내는 수학적인 공식을 만들 수가 있다.</p>\n<p>그 공식과 프로세스들이 시스템에 도착하는 시간의 분포를 통해 평균 처리량, 이용률, 대기 시간을 계산하는 것이 가능하다는 의미로 이해함!</p>\n<p>간단하게 프로세스들의 도착 시간과 CPU 처리율의 입력값을 통해 확률 분포와 같은 수학을 이용하여 각종 성능 지표(평균 처리량, 이용률, 대기 시간)를 구하는 방식이다.</p>\n<p>큐잉 모델은 각 스케줄링 알고리즘을 비교할 때 유용하지만, 사용 가능한 알고리즘에 제한이 있고 분포의 부류가 상당히 제한되어있으며, 복잡한 알고리즘은 수학적 분석이 어렵다고 한다.</p>\n<h3 id=\"시뮬레이션\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98\" aria-label=\"시뮬레이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시뮬레이션</h3>\n<p>실제 시스템에 구현해서 수행하는 것이 아니라 가상으로 CPU 스케줄링 프로그램을 통해서 입력값에 따라 결과를 수집하고 통계를 내어 측정하는 방식이다.</p>\n<h3 id=\"구현\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84\" aria-label=\"구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구현</h3>\n<p>실제로 시스템에 CPU 스케줄링을 적용하여 실행 시간을 측정하는 방법이다.</p>\n<p>하지만, 비용이 많이 든다.</p>","frontmatter":{"title":"스케줄링 알고리즘","date":"10월 08일, 2020"}}},"pageContext":{"slug":"/study/os-study/cpu-scheduling/","previous":{"fields":{"slug":"/study/javascript-coding-skill/chapter06/"},"frontmatter":{"title":"JCS - 매개변수와 return 문을 정리하라","category":"book-javascript-coding-skill","draft":false}},"next":null}},"staticQueryHashes":["3128451518","911025623"]}